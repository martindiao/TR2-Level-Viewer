
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
//using System.KeyMapper.Runtime.InteropServices; //for marshaling codes

/*
 * State:
 * Maps Lara's unity animation clip to her in game state id
 * */
public class State
{
	public string name = " ";
	public int StateID = -1;
	public int AnimationID = -1;
	
	public bool loop = false;
	public float Speed = 6.0f;
	public bool OnAir = false;
	public bool moving = false;
	public Vector3 movedir = Vector3.forward;
	
	public State prev = null;
	public State next = null;

	public AudioClip[] sfx = null;
	
	public State(string name, int id, int aimationid)
	{
		this.name = name;
		StateID = id;
		AnimationID = aimationid;
	}
}

/*
 * Action:
 * Handles set of custom states. Intended to build up complex behaviour out of simple states
 * */
public class Action  
{
	public List<State> state;
	public List<int> nloop = null;
	public List<float> delay = null;
	
	public float time = 0.0f;
	int current_state = 0;
	public string name = "";
	public void Reset()
	{
		current_state = 0;
		time = 0.0f;
	}
	public Action(string name)
	{
		this.name = name;
		state = new List<State>();
		nloop = new List<int>();
		delay = new List<float>();
	}
	
	public void AddState(State state, int nloop, int delay)
	{
		this.state.Add(state);
		this.nloop.Add(nloop);
		this.delay.Add(delay);
	}
	
	public State GetNextState()
	{
		//cyclic indexing 
		State retval = state[current_state % state.Count];
		current_state++;
		return retval;
	}
}

//public enum KeyState
//{
//	NoKey,
//	KeyMapper.Down,
//	Up
//}

public enum SwimmingState{
		None = 0,
		InShallowWater = 32,
		InDeepWater = 64,
		InWaterSurface = 96,
        Diving = 128
	}

public delegate void OnJumpDelegate(Vector3 From, Vector3 To, Quaternion rot , float sign);
public delegate void OnMovementDelegate(Vector3 dir, float speed);
public delegate void OnJumpingDelegate(Vector3 dir);

public class LaraStatePlayer: MonoBehaviour {
	//public tr2_moveable_struct movableobj;
	Transform thistransform;
	Animation rootanim;
	public List<TRAnimationClip> tranimations = null;
	int prevkeystate = 0;
	int currentkeystate = 0;
	AnimationEvent animevent = null;
	AnimationState crossfadestate = null;
	float crossfadetimeout = 0.0f;
	
	State[] statemap = null;
	Action[] actions = null;
	Action current_action = null;
	State  current_state = null;
	
	float walkstepsize = 256.0f;
	float runstepsize = 512.0f;
	float jumpstepsize = 1024.0f;
	float movementtime = 0.0f;
	
	Physic3D physics = null;
	bool shortjump = false;
	bool collide = false;
	bool dying = false;
	bool taking_damage = false;
	public bool OnAir = false;
	public bool crossfading = false;
	public bool busy = false;
    public bool diving = false;

	AudioSource SfxSource = null;
	//These are events that handled elsewhere. Events are generated from this class
	public static event OnJumpDelegate OnJump;
	public static event OnMovementDelegate OnMovement;
	public static event OnJumpingDelegate OnJumping;

	//flags for swimming staatee
	public SwimmingState m_SwimState = SwimmingState.None;
    float m_CurrentAnimationFrameTime = 0;

    AudioClip sfx_dive;
    AudioClip sfx_dive_shallow;
    AudioClip sfx_pull_out_water;
    AudioClip sfx_landed_from_jump;
    AudioClip sfx_start_jump;

    // Use this for initialization
    void Start () {
		
		//Animation state codes are coupled with keycodes. Initialised Keymapper first.
		KeyMapper.InitKeyCode();

		animevent = new AnimationEvent();
		//tranimations = movableobj.AnimClips;

		/*
		 * Showing how I looked up animation clip to its engine state ID.
		 * For example Idle animation is mapped to state id 2. Actually engine uses Idle animation
		 * via its state id 2. This mapping is realized throgh tranimations list. I had to
		 * go through error and trial process to realize this map. Here was my procedure:
		 * 
		 * First I selected a animation clip, for example Idle, by playing it. I use AnimationTester.cs for that
		 * Then look up the clip index and I index it into tranimations[clip index].stateid and logged the stateid
		 * Then I creat a new State(name, logged_stateid, animation_clip_id)  
		 * Then assign that State object to a predifined location of statemap[] array.
		 * More animation could be mapped this way. In that case statemap[] should be resized
		 * 
		 * Index to statemap[] array is generated by KeyMapper class, for eaxample KeyMapper.Walk
		 * 
		 * 
		 
			Debug.Log("Anim ID: KeyMapper.Idle" + "103" + " " + "State ID:" +  tranimations[103].stateid);     //2
			Debug.Log("Anim ID: KeyMapper.Walk" + "1" + " " + "State ID:" +  tranimations[1].stateid);         //0
			Debug.Log("Anim ID: KeyMapper.Run" + "0" + " " + "State ID:" +  tranimations[0].stateid);          //1
			Debug.Log("Anim ID: KeyMapper.Run A bit" + "6" + " " + "State ID:" +  tranimations[0].stateid);    //1
		
			Debug.Log("Anim ID: jump start A " + "26" + " " + "State ID:" +  tranimations[26].stateid);    //19
			Debug.Log("Anim ID: jump start B " + "27" + " " + "State ID:" +  tranimations[27].stateid);    //28
			Debug.Log("Anim ID: jump start C " + "28" + " " + "State ID:" +  tranimations[28].stateid);    //28
		
			Debug.Log("Anim ID: jump air " + "77" + " " + "State ID:" +  tranimations[77].stateid);    //3
			Debug.Log("Anim ID: jump Back " + "89" + " " + "State ID:" +  tranimations[89].stateid);     //5
			Debug.Log("Anim ID: Flip Back " + "75" + " " + "State ID:" +  tranimations[75].stateid);     //25
		
			Debug.Log("Anim ID: Jump Right " + "80" + " " + "State ID:" +  tranimations[80].stateid);     //26
			Debug.Log("Anim ID: Jump Right " + "78" + " " + "State ID:" +  tranimations[78].stateid);     //27
		
			Debug.Log("Anim ID: KeyMapper.Roll Right " + "81" + " " + "State ID:" +  tranimations[81].stateid);     //26
			Debug.Log("Anim ID: KeyMapper.Roll KeyMapper.Left " + "79" + " " + "State ID:" +  tranimations[79].stateid);     //27
		
			Debug.Log("Anim ID: Step KeyMapper.Left " + "12" + " " + "State ID:" +  tranimations[12].stateid);     //6
			Debug.Log("Anim ID: Step Right " + "13" + " " + "State ID:" +  tranimations[13].stateid);     //7
		
			Debug.Log("Anim ID: Throw Flare " + "189" + " " + "State ID:" +  tranimations[189].stateid);    //0
			Debug.Log("Anim ID: Pickup Flare " + "204" + " " + "State ID:" +  tranimations[204].stateid);    //67
			Debug.Log("Anim ID: Light Flare " + "257" + " " + "State ID:" +  tranimations[204].stateid);    //
		
			Debug.Log("Anim ID: Action " + "11" + " " + "State ID:" +  tranimations[11].stateid);    //
			Debug.Log("Anim ID: Switching " + "197" + " " + "State ID:" +  tranimations[197].stateid);    // 40
			//Debug.Log("Anim ID: KeyMapper.DrawWeapon " + "218" + " " + "State ID:" +  tranimations[218].stateid);    //
		
			Debug.Log("Anim ID: Grab " + "172" + " " + "State ID:" +  tranimations[172].stateid);    // 56
			Debug.Log("Anim ID: PullUpLow " + "42" + " " + "State ID:" +  tranimations[42].stateid);    //2
			Debug.Log("Anim ID: PullUpHigh " + "97" + " " + "State ID:" +  tranimations[97].stateid);    //19
			Debug.Log("Anim ID: PullUpAcrobatic " + "159" + " " + "State ID:" +  tranimations[159].stateid);    //54
			Debug.Log("Anim ID: WalkUp " + "50" + " " + "State ID:" +  tranimations[50].stateid);    //2

			//pull up animations:
			//PullUpLow: When Obstackle Height == Lara's Height
			//KeyMapper.Walk Up[50]: When Obstackle Height == Lara's heap
			//Auto jump and grab[172] + pullup[PullUpHigh]: When Obstackle Height == twice Lara's Height
			//Manual jump and grab[172] + pullup[PullUpHigh]: When Obstackle Height > twice Lara's Height
			//Manual jump and grab[172] + pullupAcrobatic[PullUpAcrobatic]: When Obstackle Height > twice Lara's Height
			//simi left[136]: 
			//simi right[137]:
			//jump grab[150]:
			//switching[197]
			//61,62 : walk back
		*/
		Debug.Log("Anim ID: Wadding " + "177" + " " + "State ID:" +  tranimations[177].stateid);    //65
		
		Debug.Log("Anim ID: inwater swimming " + "86" + " " + "State ID:" +  tranimations[86].stateid);    //17
		Debug.Log("Anim ID: inwater idle " + "108" + " " + "State ID:" +  tranimations[108].stateid);    //13
		
		Debug.Log("Anim ID: surface_water swimming " + "116" + " " + "State ID:" +  tranimations[116].stateid);    //34
		Debug.Log("Anim ID: surface idle " + "110" + " " + "State ID:" +  tranimations[110].stateid);    //33
		
		Debug.Log("Anim ID: surface pullup " + "111" + " " + "State ID:" +  tranimations[111].stateid);    //33
		//build statemap and actions array.
		//Update add 4 animation layer with each layer size 32 [normal, shallow, inwater, surface ]
		statemap = new State[128 + 8];   
		actions = new Action[128 + 8];

		//statemap[KeyMapper.Search] = new State ("KeyMapper.Search", -1,-1);
		//statemap[KeyMapper.Menu] = new State( "KeyMapper.Menu", - 1,-1);
		//statemap[KeyMapper.PickupFlare] = new State ("Pickup Flare", 67,204); statemap[KeyMapper.PickupFlare].loop = false; statemap[KeyMapper.PickupFlare].moving = false;
		//statemap[KeyMapper.StepToKeyMapper.Left] = new State ("KeyMapper.StepToKeyMapper.Left", 6,12); statemap[KeyMapper.StepToKeyMapper.Left].moving = true; statemap[KeyMapper.StepToKeyMapper.Left].movedir = Vector3.left; statemap[KeyMapper.StepToKeyMapper.Left].Speed = 0.1f;
		//statemap[KeyMapper.StepToRight] = new State ("KeyMapper.StepToRight", 7,13); statemap[KeyMapper.StepToRight].moving = true; statemap[KeyMapper.StepToRight].movedir = Vector3.right; statemap[KeyMapper.StepToRight].Speed = 0.1f;
		
		statemap[KeyMapper.Jump] = new State("Jump",28,28);  statemap[KeyMapper.Jump].OnAir = true; statemap[KeyMapper.Jump].movedir = Vector3.up * 0.35f;
		statemap[KeyMapper.Idle] = new State("KeyMapper.Idle",2,103);statemap[KeyMapper.Idle].loop = true;
		//statemap[1] = new State("KeyMapper.Walk",0,1);
		//statemap[KeyMapper.PrimaryAction] = new State ("Primary Action", 2,11);
		statemap[KeyMapper.PrimaryAction] = new State ("Primary Action", 2,103);
		statemap[KeyMapper.DrawWeapon] = new State ("KeyMapper.DrawWeapon", 0,218);
		statemap[KeyMapper.Roll] = new State ("KeyMapper.Roll", -1,-1);
		
		//statemap[10] = new State ("KeyMapper.Run", 1,0);
		statemap[KeyMapper.Run] = new State ("KeyMapper.Run", 1,0);  statemap[KeyMapper.Run].loop = true; statemap[KeyMapper.Run].moving = true; statemap[KeyMapper.Run].Speed = 6;
		statemap[KeyMapper.Down] = new State ("KeyMapper.Down", -1,-1);
		statemap[KeyMapper.Left] = new State ("KeyMapper.Left", -1,-1);
		statemap[KeyMapper.Right] = new State ("Right", -1,-1);
		statemap[KeyMapper.Walk] = new State("KeyMapper.Walk",0,1); statemap[KeyMapper.Walk].loop = true; statemap[KeyMapper.Walk].moving = true;  statemap[KeyMapper.Walk].Speed = 2.0f;
		//Add some sfx to the state run. I'm not sure weather it should be done here or else where
		statemap[KeyMapper.Run].sfx = new AudioClip[2];
		statemap[KeyMapper.Run].sfx[0] = (AudioClip)Resources.Load("sfx/run", typeof(AudioClip));
		statemap[KeyMapper.Run].sfx[1] = (AudioClip)Resources.Load("sfx/run", typeof(AudioClip));


		statemap[KeyMapper.JumpAir] = new State("Jump Air",3,77);  
		statemap[KeyMapper.JumpAir].OnAir = true; 
		statemap[KeyMapper.JumpAir].moving = true; 
		statemap[KeyMapper.JumpAir].Speed = 8;
		statemap[KeyMapper.JumpAir].movedir = Vector3.forward + Vector3.up * 0.35f;

		//statemap[jumpBack] = new State("jump Back",5,89);  statemap[jumpBack].OnAir = true; statemap[jumpBack].loop = true; statemap[jumpBack].moving = true; statemap[jumpBack].movedir = -Vector3.forward;
		//statemap[FlipBack] = new State("Flip Back",25,75); statemap[FlipBack].OnAir = true; statemap[FlipBack].moving = true; statemap[FlipBack].movedir = -Vector3.forward;
		//statemap[JumpRight] = new State("Jump Right",26,81); statemap[JumpRight].OnAir = true; statemap[JumpRight].moving = true;
		//statemap[JumpKeyMapper.Left] = new State("Jump KeyMapper.Left",27,79); statemap[JumpKeyMapper.Left].OnAir = true; statemap[JumpKeyMapper.Left].moving = true;

		statemap[KeyMapper.Grab] =  new State("Grab",56,172);
		statemap[KeyMapper.PullUpLow] = new State("Grab",2,42);  statemap[KeyMapper.PullUpLow].moving = false; statemap[KeyMapper.PullUpLow].movedir = Vector3.up * 0.35f;
		statemap[KeyMapper.PullUpHigh] = new State("PullUpHigh",19,97);  statemap[KeyMapper.PullUpHigh].moving = false; statemap[KeyMapper.PullUpHigh].movedir = Vector3.up * 0.35f;
		statemap[KeyMapper.PullUpAcrobatic] = new State("PullUpAcrobatic",54,159);  statemap[KeyMapper.PullUpAcrobatic].moving = false; statemap[KeyMapper.PullUpAcrobatic].movedir = Vector3.up * 0.35f;
		statemap[KeyMapper.WalkUp] = new State("WalkUp",2,50);  statemap[KeyMapper.WalkUp].moving = false; statemap[KeyMapper.WalkUp].movedir = Vector3.up * 0.35f;
		
        //Add some sfx to the state pull up. I'm not sure weather it should be done here or else where
		statemap[KeyMapper.PullUpHigh].sfx = new AudioClip[1];
		statemap[KeyMapper.PullUpHigh].sfx[0] = (AudioClip)Resources.Load("sfx/pull_up", typeof(AudioClip));

        statemap[KeyMapper.WalkUp].sfx = new AudioClip[1];
        statemap[KeyMapper.WalkUp].sfx[0] = (AudioClip)Resources.Load("sfx/pull_up", typeof(AudioClip));

        /*
		 * 
		 * Now build a array of action, where action stores a list of State objects. Generally
		 * one state is stored in each action but more can be added to build up complex action
		 * */

        actions[KeyMapper.Idle] = new Action("KeyMapper.Idle");   
		actions[KeyMapper.PrimaryAction] = new Action ("Primary Action"); 
		actions[KeyMapper.DrawWeapon] = new Action ("KeyMapper.DrawWeapon");  
		actions[KeyMapper.Roll] = new Action ("KeyMapper.Roll"); 
		actions[KeyMapper.Run] = new Action ("KeyMapper.Run"); 
		actions[KeyMapper.Down] = new Action ("KeyMapper.Down");
		actions[KeyMapper.Left] = new Action ("KeyMapper.Left");
		actions[KeyMapper.Right] = new Action ("Right");
		actions[KeyMapper.Walk] = new Action("KeyMapper.Walk"); 
		actions[KeyMapper.Jump] = new Action("Jump"); 
		actions[KeyMapper.JumpAir] = new Action("Jump Air");  
		actions[KeyMapper.JumpAirStanding] = new Action("JumpAirStanding"); 
		//actions[KeyMapper.jumpBack] = new Action("jump Back"); //
		actions[KeyMapper.FlipBack] = new Action("Flip Back"); 
		//actions[KeyMapper.JumpRight] = new Action("Jump Right");
		//actions[KeyMapper.Jump.Left] = new Action("Jump Left"); 
		actions[KeyMapper.Grab] = new Action("Grab");
		actions[KeyMapper.PullUpLow] = new Action("PullUpLow");
		actions[KeyMapper.PullUpHigh] = new Action("PullUpHigh");
		actions[KeyMapper.PullUpAcrobatic] = new Action("PullUpAcrobatic");
		actions[KeyMapper.WalkUp] = new Action("WalkUp");

		//actions[KeyMapper.Search].AddState(statemap[KeyMapper.Search],1,0);
		//actions[KeyMapper.Menu].AddState(statemap[KeyMapper.Menu],1,0); 
		//actions[KeyMapper.PickupFlare].AddState(statemap[KeyMapper.PickupFlare],1,0); 
		//actions[KeyMapper.StepToLeft].AddState(statemap[KeyMapper.StepToLeft],1,0); 
		//actions[KeyMapper.StepToRight].AddState(statemap[KeyMapper.StepToRight],1,0); 
		actions[KeyMapper.Idle].AddState(statemap[KeyMapper.Idle],1,0);
		actions[KeyMapper.PrimaryAction].AddState(statemap[KeyMapper.PrimaryAction],1,0);
		actions[KeyMapper.DrawWeapon].AddState(statemap[KeyMapper.DrawWeapon],1,0); 
		actions[KeyMapper.Roll].AddState(statemap[KeyMapper.Roll],1,0); 
		//statemap[10] = new State ("KeyMapper.Run", 1,0);
		actions[KeyMapper.Run].AddState(statemap[KeyMapper.Run],1,0); 
		actions[KeyMapper.Down].AddState(statemap[KeyMapper.Down],1,0); 
		actions[KeyMapper.Left].AddState(statemap[KeyMapper.Left],1,0); 
		actions[KeyMapper.Right].AddState(statemap[KeyMapper.Right],1,0); 
		actions[KeyMapper.Walk].AddState(statemap[KeyMapper.Walk],1,0); 
		actions[KeyMapper.Jump].AddState(statemap[KeyMapper.Jump],1,0); 
		//actions[KeyMapper.JumpAir].AddState(statemap[KeyMapper.Run],1,0);  
		actions[KeyMapper.JumpAir].AddState(statemap[KeyMapper.JumpAir],1,0); 
		actions[KeyMapper.JumpAirStanding].AddState(statemap[KeyMapper.JumpAirStanding], 1,0);
		//actions[KeyMapper.jumpBack].AddState(statemap[KeyMapper.jumpBack],1,0);  
		actions[KeyMapper.FlipBack].AddState(statemap[KeyMapper.FlipBack],1,0);  
		//actions[KeyMapper.JumpRight].AddState(statemap[KeyMapper.JumpRight],1,0); 
		//actions[KeyMapper.JumpLeft].AddState(statemap[KeyMapper.JumpLeft],1,0); 

		actions[KeyMapper.Grab].AddState(statemap[KeyMapper.Grab],1,0);
		actions[KeyMapper.PullUpLow].AddState(statemap[KeyMapper.PullUpLow],1,0);
		actions[KeyMapper.PullUpHigh].AddState(statemap[KeyMapper.PullUpHigh],1,0);
		actions[KeyMapper.PullUpAcrobatic].AddState(statemap[KeyMapper.PullUpAcrobatic],1,0);
		actions[KeyMapper.WalkUp].AddState(statemap[KeyMapper.WalkUp],1,0);

        /*
		 * Added new states  shallow water movment  layer (offset 32)
		 * 
		 * */
        int swimstate = (int)SwimmingState.InShallowWater;

        statemap[KeyMapper.Idle + swimstate] = new State("KeyMapper.Idle: from shallow water", 2,103);statemap[KeyMapper.Idle + swimstate].loop = true;
		statemap[KeyMapper.Run + swimstate] = new State ("KeyMapper.Run: from shallow water", 65,177);  statemap[KeyMapper.Run + swimstate].loop = true; statemap[KeyMapper.Run + swimstate].moving = true; statemap[KeyMapper.Run + swimstate].Speed = 3;
		statemap[KeyMapper.Jump + swimstate] = new State("Jump: from shallow water", 28,28);  statemap[KeyMapper.Jump + swimstate].OnAir = true; statemap[KeyMapper.Jump + swimstate].movedir = Vector3.up * 0.35f;
		statemap[KeyMapper.WalkUp + swimstate] = new State("WalkUp: from shallow water", 2,50);  statemap[KeyMapper.WalkUp + swimstate].moving = false; statemap[KeyMapper.WalkUp + swimstate].movedir = Vector3.up * 0.35f;
        statemap[KeyMapper.PullUpHigh + swimstate] = new State("PullUpHigh", 19, 97); statemap[KeyMapper.PullUpHigh].moving = false; statemap[KeyMapper.PullUpHigh].movedir = Vector3.up * 0.35f;
       
        actions[KeyMapper.Idle + swimstate] = new Action("KeyMapper.Idle: from shallow water");  
		actions[KeyMapper.Idle + swimstate].AddState(statemap[KeyMapper.Idle + swimstate],1,0);

		actions[KeyMapper.Run + swimstate] = new Action ("KeyMapper.Run: from shallow water"); 
		actions[KeyMapper.Run + swimstate].AddState(statemap[KeyMapper.Run + swimstate],1,0); 
		
		actions[KeyMapper.Jump + swimstate] = new Action("Jump: from shallow water"); 
		actions[KeyMapper.Jump + swimstate].AddState(statemap[KeyMapper.Jump + swimstate],1,0); 
		
		actions[KeyMapper.WalkUp + swimstate] = new Action("WalkUp: from shallow water"); 
		actions[KeyMapper.WalkUp + swimstate].AddState(statemap[KeyMapper.WalkUp + swimstate],1,0);

        //add sfx
        statemap[KeyMapper.WalkUp + swimstate].sfx = new AudioClip[1];
        statemap[KeyMapper.WalkUp + swimstate].sfx[0] = (AudioClip)Resources.Load("sfx/splash2", typeof(AudioClip));
        statemap[KeyMapper.PullUpHigh + swimstate].sfx = new AudioClip[1];
        statemap[KeyMapper.PullUpHigh + swimstate].sfx[0] = (AudioClip)Resources.Load("sfx/pull_up", typeof(AudioClip));
        statemap[KeyMapper.Run + swimstate].sfx = new AudioClip[2];
        statemap[KeyMapper.Run + swimstate].sfx[0] = (AudioClip)Resources.Load("sfx/shallow-water", typeof(AudioClip));
        statemap[KeyMapper.Run + swimstate].sfx[1] = (AudioClip)Resources.Load("sfx/shallow-water", typeof(AudioClip));


        /*
		 * Added new states  deep water movment  layer (offset 64)
		 * 
		 * */
        swimstate = (int)SwimmingState.InDeepWater;

        statemap[KeyMapper.Idle + swimstate] = new State("KeyMapper.Idle",13,108);statemap[KeyMapper.Idle + swimstate].loop = true;
		statemap[KeyMapper.Run + swimstate] = new State ("KeyMapper.Run", 17,86);  statemap[KeyMapper.Run + swimstate].loop = true; statemap[KeyMapper.Run + swimstate].moving = true; statemap[KeyMapper.Run + swimstate].Speed = 6;
		//statemap[KeyMapper.Jump] = new State("Jump",28,28);  statemap[KeyMapper.Jump].OnAir = true; statemap[KeyMapper.Jump].movedir = Vector3.up * 0.35f;

		actions[KeyMapper.Idle + swimstate] = new Action("KeyMapper.Idle");  
		actions[KeyMapper.Idle + swimstate].AddState(statemap[KeyMapper.Idle + swimstate],1,0);

		actions[KeyMapper.Run + swimstate] = new Action ("KeyMapper.Run"); 
		actions[KeyMapper.Run + swimstate].AddState(statemap[KeyMapper.Run + swimstate],1,0);

        //add sfx
        statemap[KeyMapper.Run + swimstate].sfx = new AudioClip[2];
        statemap[KeyMapper.Run + swimstate].sfx[0] = (AudioClip)Resources.Load("sfx/swim", typeof(AudioClip));
        statemap[KeyMapper.Run + swimstate].sfx[1] = (AudioClip)Resources.Load("sfx/swim", typeof(AudioClip));

        /*
		 * Added new states  surface water movment  layer (offset 96)
		 * 
		 * */

        swimstate = (int)SwimmingState.InWaterSurface;

        statemap[KeyMapper.Idle + swimstate] = new State("Idle Surface",33,110);statemap[KeyMapper.Idle + swimstate].loop = true; statemap[KeyMapper.Idle + swimstate].Speed = 3;
		statemap[KeyMapper.Run + swimstate] = new State ("Swim Surface", 34,116);  statemap[KeyMapper.Run + swimstate].loop = true; statemap[KeyMapper.Run + swimstate].moving = true; statemap[KeyMapper.Run + swimstate].Speed = 3;
        statemap[KeyMapper.Run + swimstate].sfx = new AudioClip[2];
        statemap[KeyMapper.Run + swimstate].sfx[0] = (AudioClip)Resources.Load("sfx/treading", typeof(AudioClip));
        statemap[KeyMapper.Run + swimstate].sfx[1] = (AudioClip)Resources.Load("sfx/treading", typeof(AudioClip));

        statemap[KeyMapper.PullUpHigh + swimstate] = new State("PullUpHigh", 55, 111); statemap[KeyMapper.PullUpHigh + swimstate].moving = false; statemap[KeyMapper.PullUpHigh + swimstate].movedir = Vector3.up * 0.35f;
        statemap[KeyMapper.PullUpHigh + swimstate].sfx = new AudioClip[1];
        statemap[KeyMapper.PullUpHigh + swimstate].sfx[0] = (AudioClip)Resources.Load("sfx/splash2", typeof(AudioClip));

        actions[KeyMapper.Idle + swimstate] = new Action("Idle Surface");  
		actions[KeyMapper.Idle + swimstate].AddState(statemap[KeyMapper.Idle + swimstate],1,0);
    
		actions[KeyMapper.Run + swimstate] = new Action ("Swim Surface"); 
		actions[KeyMapper.Run + swimstate].AddState(statemap[KeyMapper.Run + swimstate],1,0);

        actions[KeyMapper.PullUpHigh + swimstate] = new Action("Pull Out From Water");
        actions[KeyMapper.PullUpHigh + swimstate].AddState(statemap[KeyMapper.PullUpHigh + swimstate], 1,0);

        actions[KeyMapper.Jump + swimstate] = new Action("Dive Into Water");
        actions[KeyMapper.Jump + swimstate].AddState(statemap[KeyMapper.Jump + swimstate], 1, 0);

        //add sfx
        statemap[KeyMapper.Run + swimstate].sfx = new AudioClip[2];
        statemap[KeyMapper.Run + swimstate].sfx[0] = (AudioClip)Resources.Load("sfx/treading", typeof(AudioClip));
        statemap[KeyMapper.Run + swimstate].sfx[1] = (AudioClip)Resources.Load("sfx/treading", typeof(AudioClip));

        statemap[KeyMapper.PullUpHigh + swimstate].sfx = new AudioClip[1];
        statemap[KeyMapper.PullUpHigh + swimstate].sfx[0] = (AudioClip)Resources.Load("sfx/splash2", typeof(AudioClip));



        /*
         * Added new states for diving (offset 128)
         * 
         * */
        swimstate = (int)SwimmingState.Diving;

        statemap[KeyMapper.Jump + swimstate] = new State("Dive Into Water", 35, 119); statemap[KeyMapper.Jump + swimstate].OnAir = false;
        actions[KeyMapper.Jump + swimstate] = new Action("Dive Into Water");
        actions[KeyMapper.Jump + swimstate].AddState(statemap[KeyMapper.Jump + swimstate], 1, 0);



        //state map for dive in air
        statemap[KeyMapper.DiveInAir] = new State("Dive Air", 52, 156);

        actions[KeyMapper.DiveInAir] = new Action("Dive in air");
        actions[KeyMapper.DiveInAir].AddState(statemap[KeyMapper.DiveInAir], 1, 0);


        thistransform = transform;
		SfxSource = gameObject.AddComponent<AudioSource>();
		SfxSource.volume = 0.35f;
		rootanim = (Animation) GetComponent(typeof(Animation));
		//initialse states
		prevkeystate = currentkeystate = KeyMapper.Idle + (int)m_SwimState;
		current_action = actions[KeyMapper.Idle + (int)m_SwimState ];
		current_state = actions[KeyMapper.Idle + (int)m_SwimState ].state[0];
		if(current_state.AnimationID < rootanim.GetClipCount()) 
		{
			rootanim.Play("" + current_state.AnimationID);
		}
		rootanim.wrapMode = WrapMode.Loop;
		current_action.time = Time.time;
		crossfading = false;
		busy = false;
		Debug.Log(current_state.name);
	}
	
	
	int animid = 0;
	// Update is called once per frame
	void Update () 
	{
		/*
		 * Used for animation clip look up directly
		 * 
		if(Input.GetKeyUp(KeyCode.UpArrow))
		{
			rootanim.Play("" + animid);
			Debug.Log("" + animid);
			animid++;
		}

		if(Input.GetKeyUp(KeyCode.KeyMapper.DownArrow))
		{
			rootanim.Play("" + animid);
			Debug.Log("" + animid);
			animid--;
		}*/
	}
	
	/*
	 * I used FixedUpdate() for animation time control. It gives consistent key frame timing.
	 * Be careful to set Fixed time step in Project settings -> Time. A time step of 0.02 should
	 * be OK.
	 * */
	void FixedUpdate()
	{
		ControllCharacter();
		AnimationUpdate();
	}
	
	void InitAction(int keystate, float time )
	{
        if (keystate >= actions.Length) return;
		if(actions[keystate] != null)
		{
			current_action.Reset();
			State fromstate = current_action.state[0];
			State tostate = actions[keystate].state[0];
			current_action = actions[keystate];
			current_action.Reset();
			currentkeystate = keystate;
			prevkeystate = keystate;
			
			StateCrossFade(fromstate, tostate);
		}
	}
	
	void AnimationUpdate()
	{
		if(!crossfading)
		{
			if(current_action!= null && current_state!=null && current_state.AnimationID != -1 && !collide)
			{
				if(current_state.AnimationID>= rootanim.GetClipCount()) return;
				//rootanim.Play("" + current_state.AnimationID);
				AnimationState animstate = rootanim["" + current_state.AnimationID];
                m_CurrentAnimationFrameTime = Time.time - current_action.time;
                animstate.time = m_CurrentAnimationFrameTime;
                //Debug.Log(animstate.speed);

                if (m_SwimState == SwimmingState.None || m_SwimState == SwimmingState.InShallowWater)
                {
                    if (Mathf.Repeat(m_CurrentAnimationFrameTime, animstate.length * 0.5f) < 0.1f)
                    {
                        HandleSFX(currentkeystate);
                    }
                }
                else
                {
                    if (Mathf.Repeat(m_CurrentAnimationFrameTime, animstate.length ) < 0.1f)
                    {
                        HandleSFX(currentkeystate);
                    }
                }

				if(m_CurrentAnimationFrameTime > 0)  //custom animation event
				{
					busy = true;
					HandleState(animstate);
				}
				else if(m_CurrentAnimationFrameTime > animstate.length)
				{
					busy = false;
					current_action.time = Time.time;
				}
			}
		}
	}
	
	void HandleState(AnimationState animstate)
	{
	
        //Check state change
		if(prevkeystate != currentkeystate && OnAir == false)
		{
			//Debug.Log("["+ Time.time + "]" + " currentkeystate:" + currentkeystate + " prevkeystate: "+ prevkeystate);
			GotoState(currentkeystate);
			
		}
		else
		{
			/*if(current_action!= null && current_state!=null && current_state.AnimationID != -1)
			{
				if(current_state.loop)
				{
					//current_state= current_action.GetNextState();
					StateCrossFade(current_state, current_action.GetNextState());
				}
			}*/
			
		}
	}
	
	void GotoState(int state)
	{
		if(state == (KeyMapper.Idle + (int)m_SwimState))
		{
			KeyMapper.reset = true;	
		}
		
		HandleSFX(state);
		prevkeystate = state;
		InitAction(state,Time.time);
	}


	public void OnCollision(GameObject other)
	{
        if (other != null)
        {
            Debug.Log("Player Collide With Object:" + other.name);

            if (OnAir)
            {
                SoundMananger.PlayLandedSFX();
            }
        }

		//collide = true;
		OnAir = false;
		shortjump = false;
		GotoState(KeyMapper.Idle + (int)m_SwimState);
		
		Debug.Log("OnCollision:" + m_SwimState);
        diving = false;

    }

	public void OnPullUp(int statecode)
	{
		OnAir = false;
		currentkeystate = statecode + (int)m_SwimState;
        PlayPullUpSFX();
    }

    public void Dive()
    {
        diving = true;
        GotoState(KeyMapper.DiveInAir + (int)m_SwimState);
    }


	/*public void OnExitCollision(Collider other)
	{
		Debug.Log("Player OnExitCollision:" + other.name);
		collide = false;
	}*/

	//StateCode
	int firstkeystate = 0;
	int secondkeystate = 0;

	public void StateCodeHandler(int keystate, int otherkey, float time)
	{
        if (diving) return;
		//if(keystate == jumpBack) return;
		if(OnAir || collide) return;
		//if(busy) return;

		firstkeystate = keystate;
		secondkeystate = otherkey;
		if(secondkeystate == 0)
		{
			Invoke("FinalizeStateCode", 0.01f);
		}
		
		if(secondkeystate != 0)
		{
			currentkeystate = firstkeystate;
		}
		//Debug.Log(" FinalizeStateCode: " +  firstkeystate );
		/*if(prevkeystate == KeyMapper.Idle)
		{
			HandleState(rootanim["" + current_state.AnimationID]);
		}*/
	}
	
	void FinalizeStateCode()
	{
		if(secondkeystate == 0)
		{
            currentkeystate = firstkeystate + (int)m_SwimState;
            //Debug.Log(" FinalizeStateCode: " + firstkeystate);
			//Debug.Log(" State Layer: " + (int)m_SwimState);
        }
    }

	public void IdleStateHandler(int keystate , float time)
	{
        if (diving) return;
		if(OnAir) return;
		//if(busy) return;
		currentkeystate = keystate + (int)m_SwimState;
	}

	float slowmotion = 1.0f;
	public void ControllCharacter()
	{
		//Debug.Log("["+ time + "]" + " keystate:" + keystate + " prevkeystate: "+ prevkeystate);
		if(current_action!= null && current_state!=null && !collide)
		{
			if(!OnAir)
			{
				if(current_state.moving)
				{
					Vector3 dir =   thistransform.rotation * current_state.movedir;
					if(OnMovement!=null) OnMovement(dir, current_state.Speed * tranimations[current_state.AnimationID].framerate);
				}
			}
			else
			{
				Vector3 dir =   thistransform.rotation * current_state.movedir;
				if(OnJumping !=null) OnJumping(dir);

			}
		}
	}


	static TRAnimStateChange gunitystatechange = null;
	static int animdispatchcount = 0;
    static State from_state = null;
    static Parser.Tr2AnimDispatch dispatcher = null;

    void StateCrossFade(State from, State to)
	{
		if(from!=null && from.StateID !=-1  && to!=null && to.StateID!= -1)
		{
			//Debug.Log("Cross fade");
			Debug.Log("Cross fade from: " + from.name + " to:" + to.name );
			int nstatechange = 	tranimations[from.AnimationID].statechanges.Count;
			for(int statechangeid = 0; statechangeid < nstatechange; statechangeid++)
			{	
				TRAnimStateChange unitystatechange = tranimations[from.AnimationID].statechanges[statechangeid];
				if(unitystatechange.stateid == to.StateID)
				{
					gunitystatechange = unitystatechange;
					animdispatchcount = 0;
					crossfading = true;
					rootanim.Stop();
					current_state = to;
                    from_state = from;

                    if (from == statemap[KeyMapper.Idle + (int)m_SwimState])
					{
                        int nextanim = -1;
                        if (gunitystatechange.tr2dispatchers.Count > 0)
                        {
                            Parser.Tr2AnimDispatch unityanimdispacher = gunitystatechange.tr2dispatchers[animdispatchcount];
                            nextanim = unityanimdispacher.NextAnimation;
                        }

                        Debug.Log("Cross fade from: " + from.AnimationID + " to: " + nextanim + "where state id" + unitystatechange.stateid + "Number of sequence" + gunitystatechange.tr2dispatchers.Count);

                        if (nextanim == 190 && m_SwimState == SwimmingState.InWaterSurface) break;

                    }
                    dispatcher = SelectDispatcher(gunitystatechange, from_state.AnimationID, m_CurrentAnimationFrameTime);
                    CrossFadeHandler();
					return;
				}
			}
			
			//if(from == statemap[Jump])
			//Debug.Log("Failed to Cross fade from: " + from.name + " to:" + to.name);
			rootanim.Stop();
			current_state = to;
			PlayCurrentState(to);

		}
	}
	
	void CrossFadeHandler()
	{
        if(dispatcher != null)
        {
            rootanim.Play("" + dispatcher.NextAnimation);
            //dispatcher.NextFrame
            rootanim.wrapMode = WrapMode.Once;
            Invoke("CrossFadeHandler", tranimations[dispatcher.NextAnimation].endtime);
            dispatcher = null;
        }
        else
        {
            PlayCurrentState(current_state);
        }
	}

    Parser.Tr2AnimDispatch SelectDispatcher(TRAnimStateChange target_statechange,int current_anim_id, float current_frame_time)
    {

        if (target_statechange == null) return null;

        //Calculate Animation Frame Index relative to Entity (Lara)

        int frame_offset = (int)(current_frame_time / tranimations[current_anim_id].time_per_frame);
        int current_frame_index = tranimations[current_anim_id].start_animation_frame_index + frame_offset;

        for (int i = 0; i < target_statechange.tr2dispatchers.Count; i++ )
        {
            Parser.Tr2AnimDispatch dispatcher = target_statechange.tr2dispatchers[i];
            if (current_frame_index >= dispatcher.Low && current_frame_index <= dispatcher.High)
            {
                return dispatcher;
            }
        }
        return null;
    }

    void PlayCurrentState(State state)
	{
		crossfading = false;
		if(current_action!= null && state!=null && state.AnimationID != -1)
		{
			rootanim.Play("" + state.AnimationID);
			if(state.loop)
			{
				rootanim.wrapMode = WrapMode.Loop;
			}
			else
			{
				rootanim.wrapMode = WrapMode.Once;
			}
 			current_action.time = Time.time;

            //setup animation events
            if (!diving)
            {
                OnAir = state.OnAir;

                if (OnAir)
                {
                    Vector3 jumpdir = thistransform.rotation * state.movedir;
                    //Notify Jump Physics Handler
                    if (OnJump != null) OnJump(thistransform.position, jumpdir * 2048 * Settings.SceneScaling, transform.rotation, (state.movedir.x + state.movedir.z));
                    SoundMananger.PlayStartJumpFX();
                }
            }
		}
	}
	
	void HandleSFX(int state)
	{
		//TODO: SFX should bee played in specified event handler
		if(state == KeyMapper.Run 
            ||state == KeyMapper.Walk 
            || state == (KeyMapper.Run + (int) SwimmingState.InDeepWater) 
            || state == (KeyMapper.Run + (int)SwimmingState.InWaterSurface) 
            || state == (KeyMapper.Run + (int)SwimmingState.InShallowWater))
		{
            if (current_state != null && current_state.sfx != null)
            {
                SoundMananger.PlayMovementSFX(current_state.sfx[0]);
            }

		}

	}

    public void PlayPullUpSFX()
    {
        if (m_SwimState == SwimmingState.None
            || m_SwimState == SwimmingState.InWaterSurface
            || m_SwimState == SwimmingState.InShallowWater)
        {
            //if (current_state != null && current_state.sfx != null)
            //{
                SoundMananger.PlayPullUpSFX(statemap[KeyMapper.PullUpHigh + (int) m_SwimState].sfx[0]);
           // }
        }
    }

    public void PlayWalkUpSFX()
    {
        if (m_SwimState == SwimmingState.None || m_SwimState == SwimmingState.InShallowWater)
        {
            if (current_state != null && current_state.sfx != null)
            {
                SoundMananger.PlayWalkUpSFX(current_state.sfx[0]);
            }
        }
    }

    public void PlayDiveSFX()
    {
       // if (m_SwimState == SwimmingState.None || m_SwimState == SwimmingState.Diving)
       // {
                SoundMananger.PlayDiveSFX();
        //}
    }

    /*
	 * TODO:
	 * Interface defination of some special response state
	 * */

    public void LaraTakeDamageFront()
	{
		//animation clip id 126
	}
	public void LaraTakeDamageLeft()
	{
		//animation clip id 127
	}
	
	public void LaraTakeDamageRight()
	{
		//animation clip id 128
	}
	
	public void LaraDieFromFlame()
	{
		//animation clip id 138
	}
	
	public void LaraDieFromSpike()
	{
		//animation clip id 149
	}
	
	public void LaraDieHittingGround()
	{
		//animation clip id 139
	}
	
	public  void SetSwimState(SwimmingState swimstate  )
	{
		m_SwimState = swimstate;
	}
}
